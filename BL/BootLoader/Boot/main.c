#define F_CPU 8000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/boot.h>
#include <string.h>
#include <stdlib.h>
#include "UART.h"
#include "LCD.h"

// This array contains the binary code of the LED (on PB5) fast blinking program
// program size: 162 bytes
uint8_t program_bin[914]= {
  0x45, 0xc0, 0x00, 0x00, 0x60, 0xc0, 0x00, 0x00, 0x5e, 0xc0, 0x00, 0x00,
  0x5c, 0xc0, 0x00, 0x00, 0x5a, 0xc0, 0x00, 0x00, 0x58, 0xc0, 0x00, 0x00,
  0x56, 0xc0, 0x00, 0x00, 0x54, 0xc0, 0x00, 0x00, 0x52, 0xc0, 0x00, 0x00,
  0x50, 0xc0, 0x00, 0x00, 0x4e, 0xc0, 0x00, 0x00, 0x4c, 0xc0, 0x00, 0x00,
  0x4a, 0xc0, 0x00, 0x00, 0x48, 0xc0, 0x00, 0x00, 0x46, 0xc0, 0x00, 0x00,
  0x44, 0xc0, 0x00, 0x00, 0xf9, 0xc0, 0x00, 0x00, 0x40, 0xc0, 0x00, 0x00,
  0xb9, 0xc0, 0x00, 0x00, 0x3c, 0xc0, 0x00, 0x00, 0x3a, 0xc0, 0x00, 0x00,
  0x38, 0xc0, 0x00, 0x00, 0x36, 0xc0, 0x00, 0x00, 0x34, 0xc0, 0x00, 0x00,
  0x32, 0xc0, 0x00, 0x00, 0x30, 0xc0, 0x00, 0x00, 0x2e, 0xc0, 0x00, 0x00,
  0x2c, 0xc0, 0x00, 0x00, 0x2a, 0xc0, 0x00, 0x00, 0x28, 0xc0, 0x00, 0x00,
  0x26, 0xc0, 0x00, 0x00, 0x24, 0xc0, 0x00, 0x00, 0x22, 0xc0, 0x00, 0x00,
  0x20, 0xc0, 0x00, 0x00, 0x1e, 0xc0, 0x00, 0x00, 0x11, 0x24, 0x1f, 0xbe,
  0xcf, 0xef, 0xd0, 0xe1, 0xde, 0xbf, 0xcd, 0xbf, 0x11, 0xe0, 0xa0, 0xe0,
  0xb1, 0xe0, 0xe6, 0xe7, 0xf3, 0xe0, 0x00, 0xe0, 0x0b, 0xbf, 0x02, 0xc0,
  0x07, 0x90, 0x0d, 0x92, 0xac, 0x31, 0xb1, 0x07, 0xd9, 0xf7, 0x21, 0xe0,
  0xac, 0xe1, 0xb1, 0xe0, 0x01, 0xc0, 0x1d, 0x92, 0xaa, 0x32, 0xb2, 0x07,
  0xe1, 0xf7, 0xd4, 0xd0, 0x56, 0xc1, 0x9c, 0xcf, 0x98, 0xb3, 0x9f, 0x70,
  0x28, 0x2f, 0x20, 0x7f, 0x92, 0x2b, 0x98, 0xbb, 0xc2, 0x98, 0xc3, 0x9a,
  0x00, 0x00, 0xc3, 0x98, 0xe3, 0xef, 0xf1, 0xe0, 0x31, 0x97, 0xf1, 0xf7,
  0x00, 0xc0, 0x00, 0x00, 0x28, 0xb3, 0x2f, 0x70, 0xf0, 0xe1, 0x8f, 0x9f,
  0xc0, 0x01, 0x11, 0x24, 0x82, 0x2b, 0x88, 0xbb, 0xc3, 0x9a, 0x00, 0x00,
  0xc3, 0x98, 0x81, 0xee, 0x94, 0xe0, 0x01, 0x97, 0xf1, 0xf7, 0x00, 0xc0,
  0x00, 0x00, 0x08, 0x95, 0x87, 0xb3, 0x8c, 0x60, 0x87, 0xbb, 0x8f, 0xef,
  0x87, 0xbb, 0x87, 0xe8, 0x93, 0xe1, 0x01, 0x97, 0xf1, 0xf7, 0x00, 0xc0,
  0x00, 0x00, 0xc3, 0x98, 0x00, 0xc0, 0x83, 0xe3, 0xcf, 0xdf, 0x82, 0xe3,
  0xcd, 0xdf, 0x88, 0xe2, 0xcb, 0xdf, 0x81, 0xe0, 0xc9, 0xdf, 0x82, 0xe0,
  0xc7, 0xdf, 0x8e, 0xe0, 0xc5, 0xdf, 0x86, 0xe0, 0xc3, 0xcf, 0x98, 0xb3,
  0x9f, 0x70, 0x28, 0x2f, 0x20, 0x7f, 0x92, 0x2b, 0x98, 0xbb, 0xc2, 0x9a,
  0xc3, 0x9a, 0x00, 0x00, 0xc3, 0x98, 0xe9, 0xef, 0xf0, 0xe0, 0x31, 0x97,
  0xf1, 0xf7, 0x00, 0xc0, 0x00, 0x00, 0x28, 0xb3, 0x2f, 0x70, 0xf0, 0xe1,
  0x8f, 0x9f, 0xc0, 0x01, 0x11, 0x24, 0x82, 0x2b, 0x88, 0xbb, 0xc3, 0x9a,
  0x00, 0x00, 0xc3, 0x98, 0x81, 0xee, 0x94, 0xe0, 0x01, 0x97, 0xf1, 0xf7,
  0x00, 0xc0, 0x00, 0x00, 0x08, 0x95, 0xcf, 0x93, 0xdf, 0x93, 0xec, 0x01,
  0x10, 0x92, 0x25, 0x01, 0x80, 0x91, 0x25, 0x01, 0xfe, 0x01, 0xe8, 0x0f,
  0xf1, 0x1d, 0x80, 0x81, 0x88, 0x23, 0x39, 0xf0, 0xd0, 0xdf, 0x80, 0x91,
  0x25, 0x01, 0x8f, 0x5f, 0x80, 0x93, 0x25, 0x01, 0xf1, 0xcf, 0xdf, 0x91,
  0xcf, 0x91, 0x08, 0x95, 0x81, 0xe0, 0x88, 0xdf, 0x80, 0xe8, 0x86, 0xcf,
  0x1f, 0x92, 0x0f, 0x92, 0x0f, 0xb6, 0x0f, 0x92, 0x11, 0x24, 0x0b, 0xb6,
  0x0f, 0x92, 0x2f, 0x93, 0x8f, 0x93, 0x9f, 0x93, 0xef, 0x93, 0xff, 0x93,
  0x80, 0x91, 0x1d, 0x01, 0x90, 0x91, 0x1e, 0x01, 0x8f, 0x30, 0x91, 0x05,
  0xe8, 0xf4, 0x2c, 0xb1, 0x84, 0x30, 0x91, 0x05, 0x20, 0xf4, 0xfc, 0x01,
  0xea, 0x5d, 0xfe, 0x4f, 0x0b, 0xc0, 0x2c, 0x36, 0x31, 0xf4, 0x88, 0xe1,
  0x8a, 0xb9, 0x81, 0xe0, 0x80, 0x93, 0x24, 0x01, 0x04, 0xc0, 0xfc, 0x01,
  0xe5, 0x5e, 0xfe, 0x4f, 0x20, 0x83, 0x80, 0x91, 0x1d, 0x01, 0x90, 0x91,
  0x1e, 0x01, 0x01, 0x96, 0x90, 0x93, 0x1e, 0x01, 0x80, 0x93, 0x1d, 0x01,
  0xff, 0x91, 0xef, 0x91, 0x9f, 0x91, 0x8f, 0x91, 0x2f, 0x91, 0x0f, 0x90,
  0x0b, 0xbe, 0x0f, 0x90, 0x0f, 0xbe, 0x0f, 0x90, 0x1f, 0x90, 0x18, 0x95,
  0x1f, 0x92, 0x0f, 0x92, 0x0f, 0xb6, 0x0f, 0x92, 0x11, 0x24, 0x8f, 0x93,
  0x9f, 0x93, 0x80, 0x91, 0x1c, 0x01, 0x8f, 0x5f, 0x80, 0x93, 0x1c, 0x01,
  0x8f, 0x30, 0x31, 0xf4, 0x9b, 0xb3, 0x88, 0xe0, 0x89, 0x27, 0x8b, 0xbb,
  0x10, 0x92, 0x1c, 0x01, 0x12, 0xbe, 0x9f, 0x91, 0x8f, 0x91, 0x0f, 0x90,
  0x0f, 0xbe, 0x0f, 0x90, 0x1f, 0x90, 0x18, 0x95, 0x86, 0xe0, 0x8a, 0xbb,
  0x4d, 0xdf, 0x80, 0xe0, 0x91, 0xe0, 0x87, 0xdf, 0x2f, 0xef, 0x83, 0xed,
  0x90, 0xe3, 0x21, 0x50, 0x80, 0x40, 0x90, 0x40, 0xe1, 0xf7, 0x00, 0xc0,
  0x00, 0x00, 0x83, 0xe3, 0x90, 0xe0, 0x2e, 0xd0, 0x78, 0x94, 0xc2, 0xe0,
  0x8b, 0xb3, 0x8c, 0x27, 0x8b, 0xbb, 0x2f, 0xef, 0x84, 0xe3, 0x9c, 0xe0,
  0x21, 0x50, 0x80, 0x40, 0x90, 0x40, 0xe1, 0xf7, 0x00, 0xc0, 0x00, 0x00,
  0x80, 0x91, 0x24, 0x01, 0x81, 0x30, 0x81, 0xf7, 0x10, 0x92, 0x24, 0x01,
  0x8e, 0xe0, 0x91, 0xe0, 0x64, 0xdf, 0x8f, 0xe1, 0x91, 0xe0, 0x1d, 0xd0,
  0xbc, 0x01, 0x84, 0xe0, 0x90, 0xe0, 0x4f, 0xd0, 0x66, 0xe4, 0x70, 0xe0,
  0x86, 0xe0, 0x90, 0xe0, 0x39, 0xd0, 0xf8, 0x94, 0x6d, 0xdf, 0x8f, 0xe1,
  0x9e, 0xe4, 0x01, 0x97, 0xf1, 0xf7, 0x00, 0xc0, 0x00, 0x00, 0x0c, 0x94,
  0x00, 0xf0, 0xd4, 0xcf, 0x90, 0x93, 0x90, 0x00, 0x89, 0xb9, 0x88, 0xe9,
  0x8a, 0xb9, 0x86, 0xe0, 0x80, 0x93, 0x95, 0x00, 0x08, 0x95, 0xfc, 0x01,
  0x88, 0x27, 0x99, 0x27, 0xe8, 0x94, 0x21, 0x91, 0x20, 0x32, 0xe9, 0xf3,
  0x29, 0x30, 0x10, 0xf0, 0x2e, 0x30, 0xc8, 0xf3, 0x2b, 0x32, 0x39, 0xf0,
  0x2d, 0x32, 0x31, 0xf4, 0x68, 0x94, 0x03, 0xc0, 0x0b, 0xd0, 0x82, 0x0f,
  0x91, 0x1d, 0x21, 0x91, 0x20, 0x53, 0x2a, 0x30, 0xc8, 0xf3, 0x1e, 0xf4,
  0x90, 0x95, 0x81, 0x95, 0x9f, 0x4f, 0x08, 0x95, 0x7a, 0xe0, 0x97, 0x9f,
  0x90, 0x2d, 0x87, 0x9f, 0x80, 0x2d, 0x91, 0x0d, 0x11, 0x24, 0x08, 0x95,
  0x26, 0x2f, 0xe1, 0x99, 0xfe, 0xcf, 0x9f, 0xbb, 0x8e, 0xbb, 0xe0, 0x9a,
  0x01, 0x97, 0x0d, 0xb2, 0x02, 0x16, 0x31, 0xf0, 0x2d, 0xbb, 0x0f, 0xb6,
  0xf8, 0x94, 0xe2, 0x9a, 0xe1, 0x9a, 0x0f, 0xbe, 0x08, 0x95, 0x01, 0x96,
  0x27, 0x2f, 0xed, 0xdf, 0xeb, 0xcf, 0xf8, 0x94, 0xff, 0xcf, 0x46, 0x69,
  0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x56, 0x30, 0x2e, 0x30, 0x00,
  0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x56, 0x30, 0x2e,
  0x32, 0x00
  };
/**********************************************************************************************/
#define PAGESIZE 128 
#define BLINKY_PROGRAM_SIZE_IN_BYTES sizeof(program_bin)
#define BLINKY_PROGRAM_NUMBER_OF_PAGES ((BLINKY_PROGRAM_SIZE_IN_BYTES / PAGESIZE) + ((BLINKY_PROGRAM_SIZE_IN_BYTES % PAGESIZE == 0) ? 0 : 1))

 void write_program_pages(uint32_t first_page_address, uint8_t *program_buffer)
 {
	  uint16_t b;
	  uint16_t p;
	  uint16_t current_page_size;
	  uint32_t current_page_address;
	  uint8_t sreg_last_state;

	  // Disable interrupts.
	  sreg_last_state = SREG;
	  cli();

	  eeprom_busy_wait();

	  for (p = 0; p < BLINKY_PROGRAM_NUMBER_OF_PAGES; p++)
	  {
		  // Calculate current page size in bytes
		  if (p == BLINKY_PROGRAM_NUMBER_OF_PAGES - 1)
		  {
			  // Last page size
			  current_page_size = BLINKY_PROGRAM_SIZE_IN_BYTES -PAGESIZE * (BLINKY_PROGRAM_NUMBER_OF_PAGES - 1);
		  }
		  else
		  {
			  // Other page sizes
			  current_page_size = PAGESIZE;
		  }

		  current_page_address = first_page_address + p * PAGESIZE;

		  boot_page_erase(current_page_address);
		  boot_spm_busy_wait(); // Wait until the memory is erased.

		  for (b = 0; b < current_page_size; b += 2)
		  {
			  // Set up little-endian word
			  uint16_t w = *program_buffer++;
			  w += (*program_buffer++) << 8;

			  boot_page_fill(current_page_address + b, w);
		  }

		  boot_page_write(current_page_address); // Store buffer in flash page.
		  boot_spm_busy_wait();                  // Wait until the memory is written.
	  }

	  // Re-enable RWW-section again. We need this if we want to jump back
	  // to the application after bootloading.
	  boot_rww_enable();

	  // Re-enable interrupts (if they were ever enabled).
	  SREG = sreg_last_state;
  }

/*****************************************************************************************************/
uint16_t nn=0; char str[5]="";
void write_program_pages_fota(uint32_t first_page_address,uint16_t LEN)
{
	uint16_t page_size =128,pos=0 , num_pages= ((LEN /  page_size) + ((LEN %  page_size == 0) ? 0 : 1));
	uint16_t b;
	uint16_t p;
	uint16_t current_page_size;
	uint32_t current_page_address;
	uint8_t sreg_last_state;
	char L_Byte, H_Byte; 
	// Disable interrupts.
	sreg_last_state = SREG;
	cli();

	eeprom_busy_wait();

	for (p = 0; p <num_pages; p++)
	{
		// Calculate current page size in bytes
		if (p ==num_pages - 1)
		{
			// Last page size
			current_page_size =LEN - page_size * (num_pages - 1);
		}
		else
		{
			// Other page sizes
			current_page_size = page_size;
		}

		current_page_address = first_page_address + p * page_size;

		boot_page_erase(current_page_address);
		boot_spm_busy_wait(); // Wait until the memory is erased.

		for (b = 0; b < current_page_size; b += 2)
		{
			if (LEN%2==0)
			{
				L_Byte=USART_Receive();
				nn++;
				H_Byte=USART_Receive();
				nn++;
			}
			else
			{
				if (pos==(LEN-1))
				{
					L_Byte=USART_Receive();
					nn++;
					H_Byte=0xff;
					nn++;
				}
				else
				{
					L_Byte=USART_Receive();
					nn++;
					H_Byte=USART_Receive();	
					nn++;
				}
			}
			//sprintf(str ,"%d",nn);
			//LCD_Clear();
		    //_delay_ms(4);
			//LCD_String(str);
			USART_Transmit1(L_Byte);
			USART_Transmit1('\r');
			USART_Transmit1(H_Byte);
			USART_Transmit1('\r');
			
			// Set up little-endian word
			uint16_t w = L_Byte;
			w += (H_Byte) << 8;

			boot_page_fill(current_page_address + b, w);
		}

		boot_page_write(current_page_address); // Store buffer in flash page.
		boot_spm_busy_wait();                  // Wait until the memory is written.
	}

	// Re-enable RWW-section again. We need this if we want to jump back
	// to the application after bootloading.
	boot_rww_enable();

	// Re-enable interrupts (if they were ever enabled).
	SREG = sreg_last_state;
}

/*****************************************************************************************/

int main(void)
{
	LCD_Init();

	USART_Init( BAUD_PRESCALE);   //Initialise the USART 0 ; 

	DDRA = (1 << PA0);  // Configure LED PA0 as output
	//eeprom_update_byte ((uint8_t *)6, '0' );
	
	/**************************************************************************/	
		if ( eeprom_read_byte ((uint8_t*)0x10)==255)
		{  
			LCD_String("  Firmware V0.0");
			LCD_String_xy(1,3,"Loaded Now");
			_delay_ms(3000);
			 
			// Blink LED 10 times slowly to show that the bootloader program is starting
			for(int a=0 ; a<10 ; a++)
			{
				PORTA |= 1 << PA0; // Turn-on LED
				_delay_ms(500);
				PORTA &= ~(1 << PA0); // Turn-off LED
				_delay_ms(500);
			}
			
			eeprom_update_byte ((uint8_t *)0x10,0); 
			
			write_program_pages(0x00000,  program_bin);
			
			LCD_Clear();  _delay_ms(10); 
				
			LCD_String("Firmware Loaded");
			
			LCD_String_xy(1,2,"Successfully");
			
			_delay_ms(3000);
			
			LCD_Clear();
			
			asm("jmp 0");
		}
		/*******************************************************************************/
		if ( eeprom_read_byte ((uint8_t *)6)=='F')
		{
			eeprom_update_byte ((uint8_t *)6, '0'); _delay_ms(10);
			LCD_Clear();  _delay_ms(10);
			LCD_String("FOTA Process");  UART_SendString1("New Firmware is Loaded Now : \r\n");
			 _delay_ms(2000);
			USART_Transmit('S');
			write_program_pages_fota(0,eeprom_read_word ((uint16_t *)4));
			LCD_Clear();
			_delay_ms(100);
			LCD_String("Firmware Updated");
			LCD_String_xy(1,2,"Successfully");
			_delay_ms(2000);
			LCD_Clear();
			asm("jmp 0");
		}
		_delay_ms(1000);
		asm("jmp 0");
		
	
}
